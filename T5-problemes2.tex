\documentclass[catalan,border=15pt,class=scrartcl,multi=minipage]{standalone}

% encoding
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{babel}

% formatting and fixes
\frenchspacing
\usepackage[style=spanish]{csquotes}
\MakeAutoQuote{«}{»}

% ADD ANY SPECIFIC PACKAGES HERE
% (CHEMISTRY, CODE, PUBLISHING)
\usepackage{circuitikz}
\usetikzlibrary{circuits.logic.US,circuits.logic.IEC}
\usepackage{amsmath}
\newcommand{\iopair}[2]{\( \left(#1\right) \rightarrow #2 \)}

% other options
\setcounter{tocdepth}{6}

% hyperlink setup / metadata
\usepackage{hyperref}
\AfterPreamble{\hypersetup{
  pdfauthor={Xavier Mendez},
  pdftitle={T5. Problemes tema 2},
  pdfsubject={DGD},
}}

\begin{document}
\setlength{\parskip}{7pt}

\begin{minipage}{30em}

\paragraph{Problema 2.2}

\begin{equation*}
  f(a,b,c) = a \cdot b + \overline{a} \cdot \overline{b} + c \cdot \overline{b}
\end{equation*}

\vspace{0.5em}


\subparagraph{Apartat A}

Per fer-la només amb NOT i OR, manipulem l'expressió aplicant Morgan als productes...

\begin{equation*}
  f(a,b,c) = \overline{\overline{a} + \overline{b}} + \overline{a + b} + \overline{\overline{c} + b}
\end{equation*}

I ja està. El logigrama queda així:

\begin{center} \begin{circuitikz}[scale=1] \draw

(0.0,0) coordinate (d) node[anchor=south] {$a$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

(1.2,0) coordinate (d) node[anchor=south] {$b$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

(2.4,0) coordinate (d) node[anchor=south] {$c$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

;

\node at (4,-2) [or gate US, draw, logic gate inputs=nn] (and1) {};
\node at (4.8,-2) [not gate US, draw] (andn1) {};
\draw (and1.output) -- (andn1.input);
\foreach \a in {1,...,2}
  \draw (and1.input \a -| -0.5,0) -- (and1.input \a);

\node at (4,-3) [or gate US, draw, logic gate inputs=nn] (and2) {};
\node at (4.8,-3) [not gate US, draw] (andn2) {};
\draw (and2.output) -- (andn2.input);
\foreach \a in {1,...,2}
  \draw (and2.input \a -| -0.5,0) -- (and2.input \a);

\node at (4,-4) [or gate US, draw, logic gate inputs=nn] (and3) {};
\node at (4.8,-4) [not gate US, draw] (andn3) {};
\draw (and3.output) -- (andn3.input);
\foreach \a in {1,...,2}
  \draw (and3.input \a -| -0.5,0) -- (and3.input \a);

\draw
  (6,-3) node[or gate US, draw, logic gate inputs=nnn] (or) {}
  (or.input 1) -- ++(-0.2,0) |- (andn1.output)
  (or.input 2) -- ++(-0.2,0) |- (andn2.output)
  (or.input 3) -- ++(-0.2,0) |- (andn3.output)
  (or.output) -- ++(0.5,0) node[anchor=west] {$f$}
;

\draw
  (and1.input 1 -| 0.0,0) ++(.5,0) node[circ] {}
  (and1.input 2 -| 1.2,0) ++(.5,0) node[circ] {}

  (and2.input 1 -| 0.0,0)          node[circ] {}
  (and2.input 2 -| 1.2,0)          node[circ] {}

  (and3.input 1 -| 1.2,0)          node[circ] {}
  (and3.input 2 -| 2.4,0) ++(.5,0) node[circ] {}
;

\end{circuitikz} \end{center}


\subparagraph{Apartat B}

Per fer-la només amb NOT i AND, manipulem l'expressió aplicant Morgan a la suma...

\begin{equation*}
  f(a,b,c) = \overline{  \overline{a \cdot b} \cdot \overline{\overline{a} \cdot \overline{b}} \cdot \overline{c \cdot \overline{b}}  }
\end{equation*}

I ja està. El logigrama queda així:

\begin{center} \begin{circuitikz}[scale=1] \draw

(0.0,0) coordinate (d) node[anchor=south] {$a$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

(1.2,0) coordinate (d) node[anchor=south] {$b$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

(2.4,0) coordinate (d) node[anchor=south] {$c$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[not gate US, draw, rotate=-90] (d_not) {}
(d_not.input) -- ++(0,.3) to[short, -*] ++(-.5,0)
(d) ++(.5,-4.7) -- (d_not.output)

;

\node at (4,-2) [and gate US, draw, logic gate inputs=nn] (and1) {};
\node at (4.8,-2) [not gate US, draw] (andn1) {};
\draw (and1.output) -- (andn1.input);
\foreach \a in {1,...,2}
  \draw (and1.input \a -| -0.5,0) -- (and1.input \a);

\node at (4,-3) [and gate US, draw, logic gate inputs=nn] (and2) {};
\node at (4.8,-3) [not gate US, draw] (andn2) {};
\draw (and2.output) -- (andn2.input);
\foreach \a in {1,...,2}
  \draw (and2.input \a -| -0.5,0) -- (and2.input \a);

\node at (4,-4) [and gate US, draw, logic gate inputs=nn] (and3) {};
\node at (4.8,-4) [not gate US, draw] (andn3) {};
\draw (and3.output) -- (andn3.input);
\foreach \a in {1,...,2}
  \draw (and3.input \a -| -0.5,0) -- (and3.input \a);

\draw
  (6,-3) node[and gate US, draw, logic gate inputs=nnn] (or) {}
  (7,-3) node[not gate US, draw] (orn) {}
  (or.input 1) -- ++(-0.2,0) |- (andn1.output)
  (or.input 2) -- ++(-0.2,0) |- (andn2.output)
  (or.input 3) -- ++(-0.2,0) |- (andn3.output)
  (or.output) -- (orn.input)
  (orn.output) -- ++(0.5,0) node[anchor=west] {$f$}
;

\draw
  (and1.input 1 -| 0.0,0)          node[circ] {}
  (and1.input 2 -| 1.2,0)          node[circ] {}

  (and2.input 1 -| 0.0,0) ++(.5,0) node[circ] {}
  (and2.input 2 -| 1.2,0) ++(.5,0) node[circ] {}

  (and3.input 1 -| 1.2,0) ++(.5,0) node[circ] {}
  (and3.input 2 -| 2.4,0)          node[circ] {}
;

\end{circuitikz} \end{center}


\subparagraph{Apartat C}

Una XOR de N entrades es comporta com una OR de N entrades, sempre que no hi hagi més d'una entrada que sigui 1. En la expressió donada:

\begin{itemize}
\item El producte $ab$ només es 1 per a les entrades $\left(1,1,0\right)$, $\left(1,1,1\right)$.
\item El producte $\overline{a}\overline{b}$ només es 1 per a les entrades $\left(0,0,0\right)$, $\left(0,0,1\right)$.
\item El producte $c\overline{b}$ només es 1 per a les entrades $\left(0,0,1\right)$, $\left(1,0,1\right)$.
\end{itemize}

L'entrada $\left(0,0,1\right)$ causa dos 1, però si restringim un dels productes:

\begin{equation*}
  f(a,b,c) = a \cdot b + \overline{a} \cdot \overline{b} + a \cdot c \cdot \overline{b}
\end{equation*}

Aquesta expressió és equivalent, però ara es compleix que, per a totes les entrades de $f$, no hi haurà més d'un producte que evaluï a 1. Per tant, la suma es pot canviar a XOR sense alterar la funció:

\begin{equation*}
  f(a,b,c) = a \cdot b \oplus \overline{a} \cdot \overline{b} \oplus a \cdot c \cdot \overline{b}
\end{equation*}

Ara només queda canviar els negats per $\left(x \oplus 1\right)$:

\begin{equation*}
  f(a,b,c) = a b \oplus \left(a \oplus 1\right) \left(b \oplus 1\right) \oplus a c \left(b \oplus 1\right)
\end{equation*}

El logigrama queda així:

\begin{center} \begin{circuitikz}[scale=1] \draw

(0.0,0) coordinate (d) node[anchor=south] {$a$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[xor gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 2)
(d_not.input 1) -- ++(0,0.2) node [anchor=south] {$1$}
(d) ++(.5,-4.7) -- (d_not.output)

(1.2,0) coordinate (d) node[anchor=south] {$b$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[xor gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 2)
(d_not.input 1) -- ++(0,0.2) node [anchor=south] {$1$}
(d) ++(.5,-4.7) -- (d_not.output)

(2.4,0) coordinate (d) node[anchor=south] {$c$} (d) -- ++(0,-4.7)
(d) ++(.5, -1) node[xor gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 2)
(d_not.input 1) -- ++(0,0.2) node [anchor=south] {$1$}
(d) ++(.5,-4.7) -- (d_not.output)

;

\node at (4,-2) [and gate US, draw, logic gate inputs=nn] (and1) {};
\foreach \a in {1,...,2}
  \draw (and1.input \a -| -0.5,0) -- (and1.input \a);

\node at (4,-3) [and gate US, draw, logic gate inputs=nn] (and2) {};
\foreach \a in {1,...,2}
  \draw (and2.input \a -| -0.5,0) -- (and2.input \a);

\node at (4,-4) [and gate US, draw, logic gate inputs=nnn] (and3) {};
\foreach \a in {1,...,3}
  \draw (and3.input \a -| -0.5,0) -- (and3.input \a);

\draw
  (5.3,-3) node[xor gate US, draw, logic gate inputs=nnn] (or) {}
  (or.input 1) -- ++(-0.2,0) |- (and1.output)
  (or.west) -- ++(-0.2,0) |- (and2.output) % terrible hack
  (or.input 2) -- ++(-0.2,0) |- (and3.output)
  (or.output) -- ++(0.5,0) node[anchor=west] {$f$}
;

\draw
  (and1.input 1 -| 0.0,0)          node[circ] {}
  (and1.input 2 -| 1.2,0)          node[circ] {}

  (and2.input 1 -| 0.0,0) ++(.5,0) node[circ] {}
  (and2.input 2 -| 1.2,0) ++(.5,0) node[circ] {}

  (and3.input 1 -| 0.0,0)          node[circ] {}
  (and3.input 2 -| 1.2,0) ++(.5,0) node[circ] {}
  (and3.input 3 -| 2.4,0)          node[circ] {}
;

\end{circuitikz} \end{center}

\end{minipage}


\begin{minipage}{30em}

\paragraph{Problema 2.4}

Del cronograma, s'extreuen els següents parells E/S:

\begin{center} \begin{tabular}{cccc}
\iopair{1,1,1}{1} & \iopair{1,0,1}{0} & \iopair{0,0,0}{0} & \iopair{0,0,0}{0} \\
\iopair{0,0,1}{1} & \iopair{1,0,0}{1} & \iopair{1,0,0}{1} & \iopair{1,1,1}{1} \\
\iopair{0,1,0}{1} & \iopair{0,1,0}{1} & \iopair{0,0,1}{1} & \iopair{1,1,0}{0} \\
\end{tabular} \end{center}

Escribim la taula de veritat de la funció (prenem com a inespecificacions els
vectors d'entrada que no apareixen al cronograma):

\begin{center} \begin{tabular}{cc}
$abc$ & $f$ \\
\hline
000 & 0 \\
001 & 1 \\
010 & 1 \\
011 & -- \\
100 & 1 \\
101 & 0 \\
110 & 0 \\
111 & 1
\end{tabular} \end{center}

\vspace{0.5em}


\subparagraph{Apartat A}

Fent simplificació en SdP amb Karnaugh:

\begin{center} \begin{tabular}{lcccc}
\hspace{-.7em} \tikz[baseline=.1em]{\node at (.5em,.5em) {$bc$}; \node at (-.5em,-.5em) {$a$}; \draw (1em,-1em) -- (-1em,1em);}
  & 00 & 01 & 11 & 10 \\
0 &  0 &  1 & -- &  1 \\
1 &  1 &  0 &  1 &  0 \\
\end{tabular} \end{center}

L'expressió simplificada en SdP:

\begin{equation*}
  f(a,b,c) = \overline{a}b + \overline{a}c + bc + a\overline{b}\overline{c}
\end{equation*}

S'aplica Morgan a la suma exterior per convertir l'expressió en NAND de NANDs:

\begin{equation*}
  f(a,b,c) = \overline{
    \overline{\overline{a}b} \cdot \overline{\overline{a}c} \cdot \overline{bc} \cdot \overline{a\overline{b}\overline{c}}
  }
\end{equation*}

Només faltaria expressar els negats com $\overline{x\cdot x}$ per eliminar les NOT, però ho farem directament en el logigrama:

\begin{center} \begin{circuitikz}[scale=1] \draw

(0.0,0) coordinate (d) node[anchor=south] {$a$} (d) -- ++(0,-5.7)
(d) ++(.5, -1) node[nand gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 1)
(d) ++(0,-0.45) node[circ] {} (d) ++(0,-0.45) -| (d_not.input 2)
(d) ++(.5,-5.7) -- (d_not.output)

(1.2,0) coordinate (d) node[anchor=south] {$b$} (d) -- ++(0,-5.7)
(d) ++(.5, -1) node[nand gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 1)
(d) ++(0,-0.45) node[circ] {} (d) ++(0,-0.45) -| (d_not.input 2)
(d) ++(.5,-5.7) -- (d_not.output)

(2.4,0) coordinate (d) node[anchor=south] {$c$} (d) -- ++(0,-5.7)
(d) ++(.5, -1) node[nand gate US, draw, logic gate inputs=nn, rotate=-90] (d_not) {}
(d) ++(0,-0.3) node[circ] {} (d) ++(0,-0.3) -| (d_not.input 1)
(d) ++(0,-0.45) node[circ] {} (d) ++(0,-0.45) -| (d_not.input 2)
(d) ++(.5,-5.7) -- (d_not.output)

;

\node at (4,-2) [nand gate US, draw, logic gate inputs=nn] (and1) {};
\foreach \a in {1,...,2}
  \draw (and1.input \a -| -0.5,0) -- (and1.input \a);

\node at (4,-3) [nand gate US, draw, logic gate inputs=nn] (and2) {};
\foreach \a in {1,...,2}
  \draw (and2.input \a -| -0.5,0) -- (and2.input \a);

\node at (4,-4) [nand gate US, draw, logic gate inputs=nn] (and3) {};
\foreach \a in {1,...,2}
  \draw (and3.input \a -| -0.5,0) -- (and3.input \a);

\node at (4,-5) [nand gate US, draw, logic gate inputs=nnn] (and4) {};
\foreach \a in {1,...,3}
  \draw (and4.input \a -| -0.5,0) -- (and4.input \a);

\draw
  (5.5,-3.5) node[nand gate US, draw, logic gate inputs=nnnn] (or) {}
  (or.input 1) -- ++(-0.2,0) |- (and1.output)
  (or.input 2) -- ++(-0.3,0) |- (and2.output)
  (or.input 3) -- ++(-0.3,0) |- (and3.output)
  (or.input 4) -- ++(-0.2,0) |- (and4.output)
  (or.output) -- ++(0.5,0) node[anchor=west] {$f$}
;

\draw
  (and1.input 1 -| 0.0,0) ++(.5,0) node[circ] {}
  (and1.input 2 -| 1.2,0)          node[circ] {}

  (and2.input 1 -| 0.0,0) ++(.5,0) node[circ] {}
  (and2.input 2 -| 2.4,0)          node[circ] {}

  (and3.input 1 -| 1.2,0)          node[circ] {}
  (and3.input 2 -| 2.4,0)          node[circ] {}

  (and4.input 1 -| 0.0,0)          node[circ] {}
  (and4.input 2 -| 1.2,0) ++(.5,0) node[circ] {}
  (and4.input 3 -| 2.4,0) ++(.5,0) node[circ] {}
;

\end{circuitikz} \end{center}


\subparagraph{Apartat B}

Ens fixem en el mapa de Karnaugh de l'apartat A. El patró «d'escacs» ens resulta familiar. Concretament, ens recorda un XOR. Fem la prova de considerar que $f(a,b,c) = a \oplus b \oplus c$, i resulta que encaixa en la taula de veritat. El logigrama queda, doncs:

\begin{center} \begin{circuitikz} \draw
  (0,1.0) coordinate (a) node[anchor=east] {$a$}
  (0,0.5) coordinate (b) node[anchor=east] {$b$}
  (0,0.0) coordinate (c) node[anchor=east] {$c$}

  (1.0,0.75) node[xor gate US, draw] (xor1) {}
  (2.3,0.25) node[xor gate US, draw] (xor2) {}

  (xor1.input 1) -- ++(-.2,0) |- (a)
  (xor1.input 2) -- ++(-.2,0) |- (b)
  (xor2.input 1) -- ++(-.2,0) |- (xor1.output)
  (xor2.input 2) -- ++(-.2,0) |- (c)
  (xor2.output) -- ++(.5,0) node[anchor=west] {$f$}
; \end{circuitikz} \end{center}


\end{minipage}

\end{document}
